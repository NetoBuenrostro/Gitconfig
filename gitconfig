[user]
    name  = 
    email = 



[core]
    editor           = vim
    filemode         = false
    bare             = false
    logallrefupdates = true
    whitespace       = tab-in-indent, trailing-space
    excludesfile     = ~/.gitignore
    # autocrlf [false, input, true]
    autocrlf         = input
    #  lf, crlf and native
    # eol              = native



[push]
    default = simple

[gc]
  auto    = 1



[alias]
    tg    = tag -l
    ci    = commit

    # Diff commands
    # =============
    dfchk = diff --check        # Check for errors combined with core.whitespace (space, tab ... )
    dc    = diff --cached --histogram
    ds    = diff --staged --histogram
    df    = diff --histogram
    dfw   = diff --word-diff
    dfnp  = !git --no-pager diff
    # Using external tools
    dftool= difftool # Default tool
    dfp4  = difftool --tool=p4merge # launch diff with p4merge
    dfvim = difftool --tool=vimdiff # launch diff with vimdiff
    mtool-meld = mergetool --tool=meld
    w     = whatchanged
    wdiff = diff --word-diff=plain
    y     = diff "@{yesterday}"
    st    = status -sb

    # Remove files from the repository, but not from my current directory
    rmc   = rm --cached

    # Adding files
    # ==================================================================
    track = add -N
    added = add -e
    addp  = add -p

    # Runing gitk with git
    k     = !gitk
    ka    = !gitk --all
    kme   = !gitk --all --author=`git config user.email`



    cp    = cherry-pick -x

    # Branching
    # ==================================================================
    co    = checkout # git co <branch>
    ## Create a new branch and switch to it ex.: git nb <branch>
    ## Create a new branch based on other and switch to it ex.: git nb <branch> <based branch>
    nb    = checkout -b
    ## Create a new branch without a parent
    nbb   = checkout --orphan

    # TODO: Check if there is any parameter passed to the function \
    # Create a new branch and name it with a string that has spaces within
    # Ex. git nbs "this is a test branch"
    # Ex. git nbs "this is a test branch based on master" master
    nbs   = "! \
        set -e; \
        set -u; \
        f() { \
            branchName=\"$( echo \"$1\" | tr -cd '[:alnum:][:blank:]-_' | tr '[:blank:]' '_' )\"; \
            git checkout -b \"${branchName}\" ${2:-}; \
        }; f"
        #branch_name=\"$( echo \"$1\" | tr -cd '[:alnum:][:blank:]' | tr ' ' '_' | tr '[:upper:]' '[:lower:]' )\"; \
        # git checkout -b ${branch_name} \

    ## Get information from the local branches
    br    = branch -v
    ## Get information from the remote branches
    re    = remote -v

    # Branch commands
    # ===============
    # Remove remote branch if git is older than 1.7.0 we can do `git push origin :<branchName>`
    #rmr  = "!f() { git push origin :$1; }; f"
    rmrbranch = push origin --delete

    # Search for any branch which include the word
    get-branch = "! \
        set -e; \
        set -u; \
        f() { \
            result=\"$( git branch | grep \"$1\" | cut -c3-)\"; \
            if [ $( printf \"${result}\" | wc -m ) -eq 0 ]; then \
                exit 1; \
            else \
                printf \"${result}\\n\"; \
            fi \
        }; f"

    brsearchall = "! \
        set -e; \
        set -u; \
        f() { \
            BRANCH=$(git get-branch $1); \
            if [ $( printf \"${BRANCH}\" | grep -cve '^\\s*$' ) -ge 1 ]; then \
                echo \"${BRANCH}\"; \
            else \
                echo \"No branch match\"; \
                exit 1; \
            fi; \
        }; f"

    brsearch = "! \
        set -e; \
        set -u; \
        f() { \
            BRANCH=$(git get-branch $1); \
            if [ $? -ne 0 ]; then \
                echo \"No branch match\"; \
                exit 1; \
            else \
                match_count=$( printf \"${BRANCH}\" | grep -cve '^\\s*$' ); \
                if [ ${match_count} -eq 1 ]; then \
                    echo \"${BRANCH}\"; \
                else \
                    echo \"Multiple branches match\"; \
                    git brsearchall \"$1\"; \
                    exit 2; \
                fi \
            fi \
        }; f"

    ##
    # Function template
    # Back slashes and semicolon have to be used because git makes one line of
    # the function, omitting them will throw errors
    ##
    # <git alias> = "! \
    #     set -e; \
    #     set -u; \
    #     f() { \
    #         # Bash
    #     }; f"

    brsearchremotes = "! \
        set -e; \
        set -u; \
        f() { \
            BRANCH=$(git branch -r | grep \"$1\" | cut -c3-); \
            if [ $? -ne 0 ]; then \
                echo \"No branch match\"; \
                exit 1; \
            else \
                match_count=$( printf \"${BRANCH}\" | grep -cve '^\\s*$' ); \
                if [ ${match_count} -eq 1 ]; then \
                    echo \"${BRANCH}\"; \
                else \
                    echo \"Multiple branches match\"; \
                    echo \"${BRANCH}\"; \
                    exit 2; \
                fi \
            fi \
        }; f"

    # checkout for a branch with a specific identifier
    cobr = "!\
        set -e; \
        set -u; \
        f(){ \
            BRANCH=\"$(git brsearch \"$1\")\"; \
            if [ $? -ne 0 ]; then \
                printf \"${BRANCH}\\n\"; \
            else \
                git co \"${BRANCH}\"; \
            fi \
        }; f"

    # Merge aliases
    # =============
    mff   = merge --ff-only
    mrp   = merge --strategy-option=patience
    plr   = pull --rebase



    # http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/#use_snapshot_stashes
    snapshot = !git stash save --keep-index "snapshot: $(date)"
    # http://stackoverflow.com/questions/1360712/git-stash-cannot-apply-to-a-dirty-working-tree-please-stage-your-changes#answer-3733698
    unstash  = !git stash show -p | git apply -3 && git stash drop

    # Log commands
    # ==================================================================
    # Formating http://git-scm.com/docs/git-log
    # Display the log including the commit content
    lg    = log -p
    lol   = log --graph --decorate --date=relative --oneline
    lola  = log --graph --decorate --date=relative --oneline --all
    lolc  = log --graph --color --pretty=format:'%C(yellow)%h%Creset - %C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'
    lolac = log --graph --color --pretty=format:'%C(yellow)%h%Creset - %C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --all
    lolf  = log --graph         --pretty=format:'%C(yellow)%h%Creset - %C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --date=relative
    lbrl  = !git for-each-ref --sort='-authordate:iso8601' --format=' %(authordate:relative)%09%(refname:short)' refs/heads
    lbra  = !git for-each-ref --sort='-authordate:iso8601' --format=' %(authordate:relative)%09%(refname:short)'


    # List branches tracking remote branches
    br-tracking     = "!git for-each-ref --format='%(refname:short)' refs/heads/* | while read LOCALBRANCH; do if ORIGIN=$(git config --get branch.$LOCALBRANCH.remote); then REMOTEBRANCH=$(git config --get branch.$LOCALBRANCH.merge); echo \"$LOCALBRANCH  ->  $ORIGIN/${REMOTEBRANCH##*/}\"; fi; done"
    # List branches not tracking remote branches
    br-no-tracking  = "!git for-each-ref --format='%(refname:short)' refs/heads/* | while read LOCALBRANCH; do if ! [ $(git config --get branch.$LOCALBRANCH.remote) ]; then echo \"$LOCALBRANCH\"; fi; done"
    # Interactively removes local branches that are not tracking remote branch
    prune-me = "!git br-no-tracking | while read -r LINE; do printf \"\nDo you want to prune %s? [y/n]\n\" \"$LINE\"; read CONFIRM </dev/tty; case "$CONFIRM" in [yY]) printf \"\nPruning '%s' from local repository ...\n\" \"$LINE\"; git branch -D \"$LINE\";; *) printf \"Skiping %s \n\n\" \"$LINE\";; esac done;"


    # Show my commits only
    log-me      = !git config user.email | xargs -I{} git lolc --author={}

    # Show information about files in the index
    ls          = ls-files

    # Shows the commits comming from the remote before merging them into our branch
    incomming   = "!git remote update -p; git log ..@{u}"
    # See them as a patch
    incomming-p = "!git remote update -p; git log ..@{u} -p"

    # Show what we will be pushing to the remote branch
    outgoing    = log @{u}..

    # Ignoring files
    # ==================================================================
    ## Show files ignored by git:
    ign         = ls-files -o -i --exclude-standard

    ## Ignoring files, undoing and listing
    ignored     = !git ls-files -v | grep "^[[:lower:]]"

    # Ignore changes in a file, if a remote commit has changed the file
    # it will overwrite the file without raise a warning
    # Those are not stored in .gitignore
    ignore      = update-index --assume-unchanged

    # Stop ignoring changes in a file
    unignore    = update-index --no-assume-unchanged



    # Amending the previous commit
    # ==================================================================
    ## Amend the previous commit adding the files from index/cached to the previous commit
    amend     = commit --amend
    ## Add the files from the index/cached to the previous commit without changing our message
    amendfile = commit --amend --no-edit
    ## add all the files in our work directory except the new ones to the previous commit
    amendall  = commit --amend --all
    ## Amend the commit message on a specific commit
    amend-msg = commit --amend -c


    # Fetch commands
    # ==============
    # Get all the changes from the server but no merge any of the branches
    fetchall = fetch --all


    # Undo commands
    # =============
    ## Remove the staged changes (This is opposite to git add)
    unstage  = reset HEAD

    ## Remove the last commit but keep the changes in the working directory
    uncommit = reset --soft HEAD^


    # Tools
    # ==================================================================
    killspace    = !git stripspace <
    killcomments = !git stripspace --strip-comments <
    addcomments = !git stripspace --comment-lines <

    # Utils
    # ==================================================================
    # Pack the repository and run, this can be used even on a not git repository
    panic       = !tar cvf ../git_panic.tar *
    # Get the repository size
    repo-size   = !git count-objects -v -H | grep -P -o '(?<=size: ).*'

[color]
    ui          = auto
    interactive = auto

[color "branch"]
    current     = yellow reverse
    local       = yellow
    remote      = green

[color "diff"]
    meta        = yellow bold
    frag        = magenta bold
    old         = red bold
    new         = green bold

[color "status"]
    added       = yellow
    changed     = green
    untracked   = cyan

[merge]
    tool        = meld
    summary     = true

[diff]
    tool        = meld
    algorithm   = patience

[difftool]
    prompt      = false

[mergetool]
    prompt      = false
    keepBackup  = false

[commit]
    template    = ~/.gitmessage

[gui]
    commitmsgwidth = 72

[difftool "vimdiff"]
    cmd = vimdiff $LOCAL $REMOTE

#[mergetool "meld"]
#    cmd = meld --diff $LOCAL $BASE $REMOTE --output $MERGED

# Using p4merge, because it let us diff images
# to call it we have to use git dfp4
[difftool "p4merge"]
    # test expansion
    cmd = ~/workspace/apps/p4v/bin/p4merge $LOCAL $REMOTE

# Allowing to just do `git push` to push the current branch to the configured upstream
[push]
    default = upstream

# Remove empty directory from svn repo as they get removed from local git
[svn]
    rmdir = true

[filter "lfs"]
    clean = git-lfs clean %f
    smudge = git-lfs smudge %f
    required = true
